# 11장 뉴스피드 시스템 설계

### 0. 뉴스피드란

사용자가 팔로우하는 계정들의 업데이트 콘텐츠들을 시간 순서 혹은 임의 순서에 따라 보여주는 개인화된 피드

![Untitled](./Untitled.webp)

### 1. 문제 설계

- 모바일 앱 및 웹 지원
- 자신의 스토리 노출 기능 및 팔로워의 스토리 확인 기능
- 시간 흐름 역순
- 최대 5천명의 팔로워
- DAU 10,000,000
- 이미지 및 비디오 등의 미디어 파일 지원 필요

### 2. 개략적 설계

**2.1. 피드 발행 (feed publishing) : 사용자가 포스팅한 데이터는 캐시와 데이터베이스에 기록되고, 친구의 뉴스피드에 전송**

- API: POST 형태로, 포스팅 내용을 body 값으로 보내 생성

![Untitled](./Untitled%201.webp)

1. 사용자: 포스팅을 올리는 주체 → POST 요청
2. 로드밸런서
3. 웹서버: 내부 서비스로 HTTP 요청 중계
4. 저장 서비스: 새 포스팅을 DB와 캐시에 저장
5. 전송 서비스: 새 포스팅을 친구의 뉴스 피드에 푸시 (뉴스 피드 데이터는 캐시에 보관하여 비용 감소)
6. 알림 서비스: 새 포스팅이 왔을음 알리거나 푸시를 보냄

**2.2.뉴스피드 생성 (news feed building): 모든 친구의 포스팅을 시간 흐름 역순으로 모아서 생성**

- API: GET 형태로, auth 헤더를 실어 전송

![Untitled](./Untitled%202.webp)

1. 사용자: 뉴스 피드를 읽는 주체 → GET 요청
2. 로밸
3. 웹 서버: 트래픽을 뉴스피드 서비스로 전송
4. 뉴스 피드 서비스: 캐시에서 피드를 가져옴
5. 캐시: 보여줄 피드 ID를 보관

### 3. 상세 설계

**3.1. 피드 발행 흐름 상세 설계**

![Untitled](./Untitled%203.webp)

- 웹서버 → 인증, 처리율 제한, 스팸 방지, 유해한 컨텐츠 방지 등의 기능 구현 필요
- 포스팅 전송(fanout) 서비스
  fanout: 사용자의 새 포스팅을 친구 관계에 있는 모든 사용자에게 전달하는 과정
  1. fanout-on-write(쓰기 시점, push model)
  - 포스팅이 완료되면 즉시 사용자의 캐시에 해당 포스팅을 기록
  - 장점
    - 실시간, 즉시 갱신
    - 읽는 데에 소요되는 시간이 짧아짐
  - 단점
    - 친구가 많은 경우, 모든 사용자의 피드를 갱신하는 데 많은 시간이 소요될 수 있음 → 핫키문제
    - 서비스를 자주 사용하지 않는 사용자의 피드도 갱신하므로 리소스 낭비 발생
  1. fanout-on-read(읽기 시점, pull model)
  - 사용자가 읽을 때 갱신
  - 장점
    - 리소스 낭비가 덜함
    - 피드를 push하지 않기 때문에 hotkey문제가 발생하지 않음
  - 단점
    - 피드를 읽는 데 많은 시간이 소요될 수 있음

**3.2. 피드 읽기 흐름 상세 설계**

![Untitled](./Untitled%204.webp)

1. 사용자의 GET 요청
2. 로밸
3. 웹서버: 뉴스피드 서비스 호출
4. 서비스
   1. 뉴스피드 캐시에서 포스팅ID 목록 가져오기
   2. 사용자 정보, 포스팅 캐시에서 포스팅 ID 기반으로 완전한 정보 가져오기
5. 사용자에게 보내주기

**캐시구조**

![Untitled](./Untitled%205.webp)

- 뉴스피드 : 뉴스 피드 ID 보관
- 콘텐츠: 포스팅 데이터 보관, 인기 컨텐츠 분리
- 소셜 그래프: 사용자 간 관계 정보 보관
- 행동: 좋아요, 답글 등의 사용자 행위 정보 보관
- 횟수: 좋아요 횟수, 답글 횟수 등의 정보 보관
